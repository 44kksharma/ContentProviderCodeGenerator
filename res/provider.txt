package %1$s.%14$s;

import java.util.ArrayList;

import android.content.ContentProvider;
import android.content.ContentProviderOperation;
import android.content.ContentProviderResult;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.OperationApplicationException;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteStatement;
import android.net.Uri;
import android.provider.BaseColumns;
import android.util.Log;

%2$s
/**
 * This class was generated by FunzioCodeGenerator
 */
 
public class %3$sProvider extends ContentProvider {

    private static final String LOG_TAG = %3$sProvider.class.getSimpleName();
    
    private static final boolean ACTIVATE_ALL_LOGS = false;

    protected static final String DATABASE_NAME = "%3$sProvider.db";

    public static final String AUTHORITY = "%4$s.provider.%3$sProvider";

    public static final Uri INTEGRITY_CHECK_URI = Uri.parse("content://" + AUTHORITY + "/integrityCheck");

    // Version 1 : Creation of the database
%16$s    public static final int DATABASE_VERSION = %15$d;

%5$s    private static final int BASE_SHIFT = 12; // DO NOT TOUCH ! 12 bits to the
    // base type: 0,
    // 0x1000, 0x2000, etc.

    private static final String[] TABLE_NAMES = {
            %6$s
    };

    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    static {
        final UriMatcher matcher = sURIMatcher;

%7$s    }

    private SQLiteDatabase mDatabase;

    @SuppressWarnings("deprecation")
    public synchronized SQLiteDatabase getDatabase(final Context context) {
        // Always return the cached database, if we've got one
        if (mDatabase == null || !mDatabase.isOpen()) {
            final DatabaseHelper helper = new DatabaseHelper(context, DATABASE_NAME);
            mDatabase = helper.getWritableDatabase();
            if (mDatabase != null) {
                mDatabase.setLockingEnabled(true);
            }
		}

        return mDatabase;
    }

    private class DatabaseHelper extends SQLiteOpenHelper {

        DatabaseHelper(final Context context, final String name) {
            super(context, name, null, DATABASE_VERSION);
        }

        @Override
        public void onCreate(final SQLiteDatabase db) {
            Log.d(LOG_TAG, "Creating %3$sProvider database");

            // Create all tables here; each class has its own method
%8$s        }

        @Override
        public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {

            // Upgrade all tables here; each class has its own method
%9$s        }

        @Override
        public void onOpen(final SQLiteDatabase db) {
        }
    }

    @Override
    public int delete(final Uri uri, final String selection, final String[] selectionArgs) {

        final int match = sURIMatcher.match(uri);
        final Context context = getContext();

        // Pick the correct database for this operation
        final SQLiteDatabase db = getDatabase(context);
        final int table = match >> BASE_SHIFT;
        String id = "0";

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "delete: uri=" + uri + ", match is " + match);
        }

        int result = -1;

        switch (match) {
%10$s                id = uri.getPathSegments().get(1);
                result = db.delete(TABLE_NAMES[table], whereWithId(id, selection), selectionArgs);
                break;
%11$s                result = db.delete(TABLE_NAMES[table], selection, selectionArgs);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        getContext().getContentResolver().notifyChange(uri, null);
        return result;
    }

    @Override
    public String getType(final Uri uri) {
        final int match = sURIMatcher.match(uri);
        switch (match) {
%12$s            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }
    }

    @Override
    public Uri insert(final Uri uri, final ContentValues values) {

        final int match = sURIMatcher.match(uri);
        final Context context = getContext();

        // Pick the correct database for this operation
        final SQLiteDatabase db = getDatabase(context);
        final int table = match >> BASE_SHIFT;
        long id;

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "insert: uri=" + uri + ", match is " + match);
        }

        Uri resultUri = null;

        switch (match) {
%11$s                id = db.insert(TABLE_NAMES[table], "foo", values);
                resultUri = id == -1 ? null : ContentUris.withAppendedId(uri, id);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        // Notify with the base uri, not the new uri (nobody is watching a new
        // record)
        getContext().getContentResolver().notifyChange(uri, null);
        return resultUri;
    }

    @Override
    public ContentProviderResult[] applyBatch(final ArrayList<ContentProviderOperation> operations) throws OperationApplicationException {
        final SQLiteDatabase db = getDatabase(getContext());
        db.beginTransaction();
        try {
            final int numOperations = operations.size();
            final ContentProviderResult[] results = new ContentProviderResult[numOperations];
            for (int i = 0; i < numOperations; i++) {
                results[i] = operations.get(i).apply(this, results, i);
                db.yieldIfContendedSafely();
            }
            db.setTransactionSuccessful();
            return results;
        } finally {
            db.endTransaction();
        }
    }
    
    @Override
    public int bulkInsert(final Uri uri, final ContentValues[] values) {

        final int match = sURIMatcher.match(uri);
        final Context context = getContext();

        // Pick the correct database for this operation
        final SQLiteDatabase db = getDatabase(context);

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "bulkInsert: uri=" + uri + ", match is " + match);
        }

        int numberInserted = 0;
        SQLiteStatement insertStmt;

        db.beginTransaction();
        try {
            switch (match) {
%13$s
                default:
                    throw new IllegalArgumentException("Unknown URI " + uri);
            }
        } finally {
            db.endTransaction();
        }

        // Notify with the base uri, not the new uri (nobody is watching a new
        // record)
        context.getContentResolver().notifyChange(uri, null);
        return numberInserted;
    }

    @Override
    public Cursor query(final Uri uri, final String[] projection, final String selection, final String[] selectionArgs, final String sortOrder) {

        Cursor c = null;
        final Uri notificationUri = %3$sContent.CONTENT_URI;
        final int match = sURIMatcher.match(uri);
        final Context context = getContext();
        // Pick the correct database for this operation
        final SQLiteDatabase db = getDatabase(context);
        final int table = match >> BASE_SHIFT;
        String id;

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "query: uri=" + uri + ", match is " + match);
        }

        switch (match) {
%10$s                id = uri.getPathSegments().get(1);
                c = db.query(TABLE_NAMES[table], projection, whereWithId(id, selection), selectionArgs, null, null, sortOrder);
                break;
%11$s                c = db.query(TABLE_NAMES[table], projection, selection, selectionArgs, null, null, sortOrder);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        if ((c != null) && !isTemporary()) {
            c.setNotificationUri(getContext().getContentResolver(), notificationUri);
        }
        return c;
    }

    private String whereWithId(final String id, final String selection) {
        final StringBuilder sb = new StringBuilder(256);
        sb.append(BaseColumns._ID);
        sb.append(" = ");
        sb.append(id);
        if (selection != null) {
            sb.append(" AND (");
            sb.append(selection);
            sb.append(')');
        }
        return sb.toString();
    }

    @Override
    public int update(final Uri uri, final ContentValues values, final String selection, final String[] selectionArgs) {

        final int match = sURIMatcher.match(uri);
        final Context context = getContext();
        // Pick the correct database for this operation
        final SQLiteDatabase db = getDatabase(context);
        final int table = match >> BASE_SHIFT;
        int result;

        if (ACTIVATE_ALL_LOGS) {
            Log.d(LOG_TAG, "update: uri=" + uri + ", match is " + match);
        }

        switch (match) {
%10$s                final String id = uri.getPathSegments().get(1);
                result = db.update(TABLE_NAMES[table], values, whereWithId(id, selection), selectionArgs);
                break;
%11$s                result = db.update(TABLE_NAMES[table], values, selection, selectionArgs);
                break;
            default:
                throw new IllegalArgumentException("Unknown URI " + uri);
        }

        getContext().getContentResolver().notifyChange(uri, null);
        return result;
    }

    @Override
    public boolean onCreate() {
        return true;
    }
}
